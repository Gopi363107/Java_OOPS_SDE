ğŸ”¥ GENERICS IN JAVA (ZERO â†’ ADVANCED)

ğŸ”¥ FINAL GENERICS GOLD RULES (MEMORIZE)

extends â†’ read only
super â†’ write allowed
Generics are invariant
No primitives in generics

Type erasure at compile time
1ï¸âƒ£ Why Generics? (MOST IMPORTANT)
âŒ Problem without Generics

import java.util.*;
public class Test {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(10);
        list.add("Gopi");

        int x = (int) list.get(1); // Runtime error
    }
}

âŒ Runtime Error
ClassCastException


ğŸ‘‰ Problem:

No type safety

Errors detected at runtime, not compile time

2ï¸âƒ£ What are Generics?

Generics allow us to define type-safe classes, methods, and collections.

âœ” Errors caught at compile time
âœ” No type casting
âœ” Cleaner & safer code

3ï¸âƒ£ Generics with Collections (BASIC)
âœ… Using Generics
import java.util.*;

public class Test {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(10);
        list.add(20);
        // list.add("Gopi"); âŒ compile-time error

        for (int x : list) {
            System.out.println(x);
        }
    }
}

ğŸ”‘ Benefits

Type safety

No casting

Faster debugging

4ï¸âƒ£ Generic Class
Example
class Box<T> {
    T value;

    void set(T value) {
        this.value = value;
    }

    T get() {
        return value;
    }
}

public class Test {
    public static void main(String[] args) {
        Box<Integer> b1 = new Box<>();
        b1.set(10);

        Box<String> b2 = new Box<>();
        b2.set("Gopi");

        System.out.println(b1.get());
        System.out.println(b2.get());
    }
}

ğŸ”‘ Key Points

T â†’ Type parameter

Same class works for multiple types

5ï¸âƒ£ Generic Method
class Test {
    static <T> void print(T data) {
        System.out.println(data);
    }

    public static void main(String[] args) {
        print(10);
        print("Hello");
        print(5.5);
    }
}


âœ” Method works for any data type

6ï¸âƒ£ Multiple Type Parameters
class Pair<K, V> {
    K key;
    V value;

    Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    void show() {
        System.out.println(key + " : " + value);
    }
}

public class Test {
    public static void main(String[] args) {
        Pair<Integer, String> p = new Pair<>(1, "Gopi");
        p.show();
    }
}

7ï¸âƒ£ BOUNDED GENERICS (VERY IMPORTANT)
ğŸ”¹ Upper Bound (extends)
class Test<T extends Number> {
    T num;

    Test(T num) {
        this.num = num;
    }

    void show() {
        System.out.println(num);
    }
}


âœ” Allows Integer, Double, Float
âŒ Does NOT allow String

ğŸ”¹ Lower Bound (super)
import java.util.*;

public class Test {
    static void addNumbers(List<? super Integer> list) {
        list.add(10);
        list.add(20);
    }

    public static void main(String[] args) {
        List<Number> list = new ArrayList<>();
        addNumbers(list);
        System.out.println(list);
    }
}


âœ” Used when adding values

8ï¸âƒ£ Wildcards (?)
Symbol	Meaning
<?>	Any type
<? extends T>	Read-only
<? super T>	Write-only
Example
static void show(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}

9ï¸âƒ£ PECS Rule (INTERVIEW FAVORITE)

PECS = Producer Extends, Consumer Super

Scenario	Use
Reading values	extends
Writing values	super
ğŸ”¥ MNC INTERVIEW TRAPS
â“ Can we use primitives in generics?

âŒ No
âœ” Use wrapper classes (Integer, Double)

â“ Are generics available at runtime?

âŒ No
âœ” Type erasure happens at compile time

â“ Can we create object of type parameter?

âŒ No

T obj = new T(); // error

ğŸ”š GENERICS SUMMARY (MEMORIZE)

Introduced in Java 5

Provides compile-time type safety

Removes ClassCastException

Uses type erasure

Works only with reference types

ğŸ§ª PRACTICE QUESTIONS (EASY â†’ HARD)
Q1 (Easy)
List<String> list = new ArrayList<>();
list.add("Java");
list.add(10);


â“ Compile or error?

Q2 (Medium)
List<? extends Number> list = new ArrayList<Integer>();
list.add(10);


â“ Compile or error? Why?

Q3 (Hard â€“ Interview)

Why List<Object> is not same as List<String>?

Reply with:
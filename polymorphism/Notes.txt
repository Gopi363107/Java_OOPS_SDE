POLYMORPHISM IN JAVA (FROM ZERO â†’ INTERVIEW LEVEL)

Polymorphism = One name, many forms

In Java, polymorphism happens in two ways:

1ï¸âƒ£ Compile-time Polymorphism
2ï¸âƒ£ Runtime Polymorphism

1ï¸âƒ£ COMPILE-TIME POLYMORPHISM (Method Overloading)
ğŸ‘‰ Happens at compile time
ğŸ‘‰ Same method name, different parameter list
Example:
class Calculator {

    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator c = new Calculator();

        System.out.println(c.add(10, 20));
        System.out.println(c.add(10.5, 20.5));
        System.out.println(c.add(1, 2, 3));
    }
}

âœ” Decided at compile time
âŒ No inheritance required
2ï¸âƒ£ RULES OF METHOD OVERLOADING (VERY IMPORTANT)

âœ” Same class
âœ” Same method name
âœ” Different number / type / order of parameters

âŒ Return type alone cannot change

int add(int a, int b)
double add(int a, int b) // âŒ ERROR

3ï¸âƒ£ RUNTIME POLYMORPHISM (Method Overriding) â­â­â­
ğŸ‘‰ Happens at runtime
ğŸ‘‰ Requires inheritance
ğŸ‘‰ Parent reference â†’ Child object
Example:
class Vehicle {
    void start() {
        System.out.println("Vehicle is starting");
    }
}

class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Car starts with key");
    }
}

public class Main {
    public static void main(String[] args) {

        Vehicle v = new Car(); // polymorphism
        v.start();  // Car's method is called
    }
}

4ï¸âƒ£ WHY RUNTIME POLYMORPHISM IS IMPORTANT?

Because:

Method call depends on object, not reference

Vehicle v = new Car();


âœ” Reference â†’ Vehicle
âœ” Object â†’ Car
âœ” Method executed â†’ Carâ€™s start()

5ï¸âƒ£ METHOD OVERRIDING RULES (VERY IMPORTANT)

âœ” Same method signature
âœ” Same return type (or covariant)
âœ” Access level cannot be reduced
âœ” @Override annotation recommended
âœ” Cannot override static, final, private

6ï¸âƒ£ Compile-Time vs Runtime Polymorphism

Feature	            Compile-Time	            Runtime

Example	            Overloading	                Overriding
Decision	        Compile time	            Runtime
Inheritance	        âŒ Not needed	        âœ… Required
Flexibility	            Less	                    More
MNC Focus	            Medium	                  ğŸ”¥ HIGH

7ï¸âƒ£ INTERVIEW TRICK QUESTION âš ï¸
Vehicle v = new Vehicle();
v.start();   // Vehicle method

Vehicle v2 = new Car();
v2.start();  // Car method


ğŸ‘‰ Same reference type
ğŸ‘‰ Different output
ğŸ‘‰ Runtime polymorphism

8ï¸âƒ£ REAL-WORLD EXAMPLE (BEST ANSWER)

A person can behave differently:

Employee at office

Customer in shop

Parent at home
Same person, different behavior â†’ polymorphism

ğŸ§ª PRACTICE TASK (DO THIS NEXT)
/* Create a class Shape with method draw()
   Create subclasses:
      Circle
      Rectangle
   Override draw()
   Call using Shape reference */
